

![](https://github.com/SeeedDocument/CAN-BUS-Shield-V2.0/raw/master/img/CAN_BUS_Shield_V2.jpg)

// loovee - 此处添加一张产品图

**CAN-BUS** is a common industrial bus because of its long travel distance, medium communication speed and high reliability. It is commonly found on modern machine tools, such as an automotive diagnostic bus.

This CAN-FD Shield adopts **MCP2517** CAN Bus controller with SPI interface and **MCP2542** CAN transceiver to give your Arduino CAN-BUS(CAN-FD) capability. With an **OBD-II** converter cable added on and the OBD-II library imported, you are ready to build an onboard diagnostic device or data logger.


**D-Sub CANbus PinOut**

|pin#|Signal names|Signal Description|
|----|----|-----------|
|1|Reserved|Upgrade Path|
|2|CAN_L|Dominant Low|
|3|CAN_GND|Ground|
|4|Reserved|Upgrade Path|
|5|CAN_SHLD|Shiled, Optional|
|6|GND|Ground，Optional|
|7|CAN_H|Dominant High|
|8|Reserved|Upgrade Path|
|9|CAN_V+|Power, Optional|



## Features
-----

- Work at CAN-FD and CAN 2.0
- Industrial standard 9 pin sub-D connector
- OBD-II and CAN standard pinout selectable.
- Changeable chip select pin
- Changeable CS pin for TF card slot
- Changeable INT pin
- Arduino Uno pin headers
- 2 Grove connectors (I2C and A0/A1)
- SPI Interface up to 10 MHz

!!!Note
    CAN-FD Shield Work well with Arduino UNO (ATmega328), Arduino Mega (ATmega1280/2560) as well as Arduino Leonardo (ATmega32U4).


## Hardware Overview
-----

![](https://github.com/SeeedDocument/CAN-BUS-Shield-V2.0/raw/master/img/CANBUS_V2_Hardware_overview.png)

1. **DB9 Interface** - to connect to OBDII Interface via a DBG-OBD Cable.
2. **V_OBD** - It gets power from OBDII Interface (from DB9)
3. **Led Indicator**:
    - **PWR**: power
    - **TX**: blink when the data is sending
    - **RX**: blink when there's data receiving
    - **INT**: data interrupt
4. **Terminal** - CAN_H and CAN_L
5. **Arduino UNO pin out**
6. **A0/A1 Grove connector**
7. **I2C Grove connector**
8. **ICSP pins**
9. **IC** - MCP2542FD, a high-speed CAN-FD transceiver ([datasheet](https://www.mouser.com/datasheet/2/268/20005514a-1102085.pdf))  
10. **IC** - MCP2517FD, stand-alone CAN controller with SPI interface ([datasheet](https://www.mouser.com/datasheet/2/268/MCP2517FD-External-CAN-FD-Controller-with-SPI-Inte-1519186.pdf))
11. **SD card slot**
12. **120Ω terminal resistor switch**


### Pin map

![](https://github.com/SeeedDocument/CAN-BUS-Shield-V2.0/raw/master/img/PingMAP_CANBUS_V2.png)

!!!note
    - The FREE pin is available for the other usages.


**Dimensions**

![](https://github.com/SeeedDocument/CAN-BUS-Shield-V2.0/raw/master/img/drawing1.png)

![](https://github.com/SeeedDocument/CAN-BUS-Shield-V2.0/raw/master/img/drawing2.png)

![](https://github.com/SeeedDocument/CAN-BUS-Shield-V2.0/raw/master/img/drawing3.png)

## Getting Started
-----
Here's a simple example to show you how CAN-BUS Shield works. In this example we need 2 pieces of CAN-BUS Shields as well as Arduino or Seeeduino.

!!!note
    This example is built under [Arduino IDE version 1.8.10](https://www.arduino.cc/en/Main/OldSoftwareReleases#1.5.x).


**STEP1: What do we need**

|Name|Function|Qty|Link|
|----|--------|---|----|
|CAN-BUS Shield|CAN Bus communication | 2 | [link](https://www.seeedstudio.com/CAN-BUS-Shield-V2-p-2921.html) |
|Seeeduino V4.2|Controller|2|[link](http://www.seeedstudio.com/item_detail.html?p_id=2517)|
|Jumper Wire|connection|2|[link](http://www.seeedstudio.com/item_detail.html?p_id=234)|

**STEP2: Hardware Connection**

Insert each CAN-BUS Shield into Seeeduino V4.2, and connect the 2 CAN-BUS Shield together via 2 jumper wires. Shown as below images.

![](https://raw.githubusercontent.com/SeeedDocument/CAN_BUS_Shield/master/image/connection.png)

!!!note
    CAN_H to CAN_H, CAN_L to CAN_L

**STEP3: Software**

Please follow [how to install an arduino library](http://wiki.seeed.cc/How_to_install_Arduino_Library/) procedures to install CAN BUS shield library.


Click [CAN-FD Library for Arduino](https://github.com/Longan-Labs/Longan_Labs_CAN_FD_Shield_Arduino/archive/master.zip) to download the library.

Install the library to your Arduino IDE when it is downloaded.

One of the node (a node means Seeeduino + CAN_BUS Shield) acts as master, the other acts as slaver. The master will send data to slaver constantly.

!!!note
    Each node can act as master before the code being uploaded.

Open the **CAN_FD_Send** example (**File > Examples > Longan_Labs_CAN_FD_Shield_Arduino > CAN_FD_Send**) and upload to the **master**.

Open the **CAN_FD_Recv** example (**File > Examples > CAN_FD_Recv > receive_check**) and upload to the **slaver**.

**STEP4: View Result**

Open the Serial Monitor of Arduino IDE(**slaver**), you will get the data sent from the master.

![](https://raw.githubusercontent.com/SeeedDocument/CAN_BUS_Shield/master/image/serial_monitor.png)
// loovee 此处添加串口输出图片

## APIs
-----

### 1.Set the Baud rate

This function is used to initialize the baud rate of the CAN Bus system.

The available baud rates are listed as follows:

	#define CAN_5KBPS    1
	#define CAN_10KBPS   2
	#define CAN_20KBPS   3
	#define CAN_25KBPS   4
	#define CAN_31K25BPS 5
	#define CAN_33KBPS   6
	#define CAN_40KBPS   7
	#define CAN_50KBPS   8
	#define CAN_80KBPS   9
	#define CAN_83K3BPS  10
	#define CAN_95KBPS   11
	#define CAN_100KBPS  12
	#define CAN_125KBPS  13
	#define CAN_200KBPS  14
	#define CAN_250KBPS  15
	#define CAN_500KBPS  16
	#define CAN_666kbps  17
	#define CAN_1000KBPS 18

### 2.Set Receive Mask and Filter

There are **2** receive mask registers and **5** filter registers on the controller chip that guarantee you getting data from the target device. They are useful especially in a large network  consisting of numerous nodes.

We provide two functions for you to utilize these mask and filter registers. They are:

**Mask:**

	init_Mask(unsigned char num, unsigned char ext, unsigned char ulData);

**Filter:**

	init_Filt(unsigned char num, unsigned char ext, unsigned char ulData);


- **num** represents which register to use. You can fill 0 or 1 for mask and 0 to 5 for filter.
- **ext** represents the status of the frame. 0 means it's a mask or filter for a standard frame. 1 means it's for a extended frame.
- **ulData** represents the content of the mask of filter.

### 3.Check Receive

The MCP2515 can operate in either a polled mode, where the software checks for a received frame, or using additional pins to signal that a frame has been received or transmit completed.

Use the following function to poll for received frames.

    INT8U MCP_CAN::checkReceive(void);

The function will return 1 if a frame arrives, and 0 if nothing arrives.

### 4.Get CAN ID

When some data arrive, you can use the following function to get the CAN ID of the "send" node.

    INT32U MCP_CAN::getCanId(void)

### 5.Send Data

    CAN.sendMsgBuf(INT8U id, INT8U ext, INT8U len, data_buf);

It is a function to send data onto the bus. In which:

* **id** represents where the data comes from.
* **ext** represents the status of the frame. '0' means standard frame. '1' means extended frame.
* **len** represents the length of this frame.
* **data_buf** is the content of this message.

For example, In the 'send' example, we have:

    unsigned char stmp[8] = {0, 1, 2, 3, 4, 5, 6, 7};
    CAN.sendMsgBuf(0x00, 0, 8, stmp); //send out the message 'stmp' to the bus and tell other devices this is a standard frame from 0x00.

### 6.Receive Data

The following function is used to receive data on the 'receive' node:

    CAN.readMsgBuf(unsigned char len, unsigned char buf);
In conditions that masks and filters have been set. This function can only get frames that meet the requirements of masks and filters.

* **len** represents the data length.
* **buf** is where you store the data.

### 7.init_CS

it is very usefule for you to use two CAN-BUS shields with one Arduino.we provide CS_CAN pin to select for you.if you cannot kown how to use CS_CAN pin , you can go to [CS_CAN pin](http://wiki.seeedstudio.com/CAN-BUS_Shield_V2.0/#cs_can-pin) to learn.

	void MCP_CAN::init_CS(byte _CS)

* **_CS** represents what you select pin.(9 or 10)



## Schematic Online Viewer

<div class="altium-ecad-viewer" data-project-src="https://github.com/Longan-Labs/Longan_Labs_CAN_FD_Eagle/archive/master.zip" style="border-radius: 0px 0px 4px 4px; height: 500px; border-style: solid; border-width: 1px; border-color: rgb(241, 241, 241); overflow: hidden; max-width: 1280px; max-height: 700px; box-sizing: border-box;" />
</div>


## Resources
-----

* [Arduino Library](https://github.com/Longan-Labs/Longan_Labs_CAN_FD_Shield_Arduino)
* [Eagle File](https://github.com/Longan-Labs/Longan_Labs_CAN_FD_Eagle/archive/master.zip)
* [MCP2517FD Datasheet](https://www.mouser.com/datasheet/2/268/MCP2517FD-External-CAN-FD-Controller-with-SPI-Inte-1519186.pdf)
* [MCP2542 Datasheet](https://www.mouser.com/datasheet/2/268/20005514a-1102085.pdf)